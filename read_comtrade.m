function read_comtrade(PathAndCfgName)

%% Comtrade Reader function
% 
% This file is designed to decode the data stored in COMTRADE format, 
% as defined in IEEE C37.111-1999. This involves the opening of two files, 
% one containing the configuration (.cfg) information and the other 
% the data (.dat).
% 
% COMTRADE provides a common format for the data files and exchange medium 
% needed for the interchange of various types of fault, test, or simulation 
% data.

%% open the comtrade files & extract the data

% read_comtrade(filename)
%  Imports data from the specified file
%  filename:  files to read <filename>.cfg and <filename>.dat

%  Auto-generated by MATLAB on 12-Jul-2007 13:45:45

%  Modified by Gopal on 31st May 2013 
%  Now able to read binary files and 2012 format
% Use the uigetfile function to load the .cfg file, which is then used to
% load the associated .dat file
%  Modified by Gopal on 20th Oct 2013
%  Now removed the annoying plot dialog when called through function form.

% First, get the .cfg file information

if nargin == 0
    [CfgFileName,Path] = uigetfile('*.cfg');
    PathAndCfgName =[Path CfgFileName];
    % Store the file name (minus extension) and path in the workspace
    assignin('caller','Path', Path);
    assignin('caller','FileName', sscanf(CfgFileName,'%1s',length(CfgFileName)-4));
end
    % Derive the .dat file string
    PathAndDatName = strcat(PathAndCfgName(1:length(PathAndCfgName)-4), '.dat');
    if ~(exist(PathAndDatName, "file") == 2)
    PathAndDatName = strcat(PathAndCfgName(1:length(PathAndCfgName)-4), '.DAT');
    end
    if ~(exist(PathAndDatName, "file") == 2)
        error("Contrade Data file not found.");
    end

% Now open the .cfg and .dat files
cfg_id = fopen(PathAndCfgName);
%dat_id = fopen(PathAndDatName);

% Scan the text into local cells cfg and dat.
%cfg = textscan(cfg_id, '%s', 'delimiter', '\n');
%dat = textscan(dat_id, '%s', 'delimiter', '\n');
%dat = dlmread(PathAndDatName, ',');

% close all open files, as we're done with them now.
%fclose('all');
%fclose(dat_id);

%% start to decode the data

%cfg_len = length(cfg{1,1});
cfg_string = cell([1,50]);
k=1;
while 1
%for i = 1:cfg_len
    %temp_string = char(cfg{1,1}{i});
    temp_string = fgetl(cfg_id);
    if ~ischar(temp_string), break, end
    %cfg_string(i) = textscan(temp_string, '%s', 'Delimiter', ',')';
    cfg_string{k} = flinescan(temp_string,',');
    k=k+1;
end
fclose(cfg_id);
% cfg_string
% Comtrade File Identifier
Title = char(cfg_string{1,1}(1));

% Comtrade Version
if length(cfg_string{1,1}) < 3 
    Version = '1991';
else
    Version = char(cfg_string{1,1}(3));
end

% Channel information: total, analogues and digitals
No_Ch = sscanf((char(cfg_string{1,2}(1))),'%d'); 
%No_Ch = strread(char(cfg_string{1,2}(1)));
%Ana_Ch = strread(char(cfg_string{1,2}(2)));
%Dig_Ch = strread(char(cfg_string{1,2}(3)));
Ana_Ch = sscanf(char(cfg_string{1,2}(2)),'%d');
Dig_Ch = sscanf(char(cfg_string{1,2}(3)),'%d');

% Data length, i.e. no of samples
dat_len = sscanf(char(cfg_string{1,5+No_Ch}(2)),'%d'); 
% Nominal frequency 
frequency = sscanf(char(cfg_string{1,3+No_Ch}(1)),'%d');

% Sampling rate
samp_rate = sscanf(char(cfg_string{1,5+No_Ch}(1)),'%d');

% Record started
start_date = char(cfg_string{1,6+No_Ch}(1));
start_time = char(cfg_string{1,6+No_Ch}(2));

% Record ended
end_date = char(cfg_string{1,7+No_Ch}(1));
end_time = char(cfg_string{1,7+No_Ch}(2));
% Type of data file
data_type = strtrim(char(cfg_string{1,8+No_Ch}(1)));

% Time multiplier
time_mult = sscanf(char(cfg_string{1,9+No_Ch}(1)),'%f');
if ~((strcmpi(data_type,'ASCII')) || (strcmpi(data_type,'binary')) ...
     || (strcmpi(data_type,'binary32')) || (strcmpi(data_type,'float32')))
error('Invalid data type. It must be either ASCII, binary, binary32 or float32');
return
end
%% Now write the data to the workspace

%dat_string = cell(size(dat));
%data = zeros(dat_len, No_Ch+2);
%
%% Now extract the data
%for i = 1:dat_len
%    dat_string(i) = textscan(char(dat{1,:}(i)), '%n', 'Delimiter', ',');
%    data(i,:) = (dat_string{:,i});
%end

if (strcmpi(data_type,'ASCII'))
    dat = dlmread(PathAndDatName, ',');
    dat(end,:) = [];
    l = size(dat,1);
elseif (strcmpi(data_type,'binary'))
    dat_id = fopen(PathAndDatName,'r');
    NR1 = Ana_Ch;
    NR2 = ceil(Dig_Ch/16);
    fseek(dat_id,0,-1); % place at start
    dat(1:2,:) = fread(dat_id,[2,inf],'2*uint32',2*(NR1+NR2),'ieee-le');
    l = size(dat,2);
    fseek(dat_id,8,-1); % place at first analog data
    dat(3:2+NR1,:) = fread(dat_id,[NR1,inf],[num2str(NR1) '*int16'],8+2*NR2,'ieee-le');
    if NR2 ~= 0
        fseek(dat_id,8+2*NR1,-1); % place at first digital data
        dat(3+NR1:2+NR1+NR2,:) = fread(dat_id,[NR2,inf],[num2str(NR2) ...
        '*uint16'],8+2*NR1,'ieee-le');
    end
    fclose(dat_id);
    dat = dat';
elseif (strcmpi(data_type,'binary32'))
    dat_id = fopen(PathAndDatName,'r');
    NR1 = Ana_Ch;
    NR2 = ceil(Dig_Ch/16);
    fseek(dat_id,0); % place at start
    dat(1:2,:) = fread(dat_id,[2,inf],'2*uint32',4*NR1+2*NR2,'ieee-le');
    l = size(dat,2);
    fseek(dat_id,8); % place at first analog data
    dat(3:2+NR1,:) = fread(dat_id,[NR1,inf],[num2str(NR1) '*int32'],8+2*NR2,'ieee-le');
    if NR2 ~= 0
        fseek(dat_id,8+4*NR1); % place at first digital data
        dat(3+NR1:2+NR1+NR2,:) = fread(dat_id,[NR2,inf],[num2str(NR2)
        '*uint16'],8+4*NR1,'ieee-le');
    end
    fclose(dat_id);
    dat = dat';
elseif (strcmpi(data_type,'float32'))
    dat_id = fopen(PathAndDatName,'r');
    NR1 = Ana_Ch;
    NR2 = ceil(Dig_Ch/16);
    fseek(dat_id,0); % place at start
    dat(1:2,:) = fread(dat_id,[2,inf],'2*uint32',4*NR1+2*NR2,'ieee-le');
    l = size(dat,2);
    l = l-1;
    fseek(dat_id,8 ); % place at first analog data
    dat(3:2+NR1,1:l) = fread(dat_id,[NR1,l],[num2str(NR1) '*float32'], 8+2*NR2,'ieee-le');
    if NR2 ~= 0
        fseek(dat_id, 8+4*NR1); % place at first digital data
        dat(3+NR1:2+NR1+NR2,1:l) = fread(dat_id,[NR2,l],[num2str(NR2)...
        '*uint16'], 8+4*NR1,'ieee-le');
    end
    fclose(dat_id);
    dat = dat';
end

data = dat(1:l,:);
% extract the timestamps, scaled to seconds from microseconds
t = (data(:,2)) * time_mult * 1e-6;

% Write the data to the workspace
assignin('caller','t', t);

var_string = cell(No_Ch);

% All channels are extracted here, but the analogues still need scaling
 for i = 1 : No_Ch
    j = i + 2;
    var_string(i) = strcat(cfg_string{1,j}(2),cfg_string{1,j}(3));
    % var_string{i} = char(cfg_string{1,j}(2)) 
    % var_string{i} = char(textscan(char(cfg_string{1,j}(2)),'%c'));
    
    % If the first character is not a letter, replace with an 'x'. This is
    % to satisfy the naming requirements for the workspace.
    if ~isletter(var_string{i}(1))
        var_string{i} = strcat('x',var_string{i});
    end
    % If any character is not a letter or number, replace with an '_'. This is
    % to satisfy the naming requirements for the workspace.
    for k = 2:length(var_string{i})
%         if ~(isletter(var_string{i}(k)) | any(sscanf(var_string{i}(k),'%d')))
        if ~(isletter(var_string{i}(k)) | isdigit(var_string{i}(k)))
            var_string{i}(k) = '_';
        end
    end
    % If the last character is not a letter, delte it. This is
    % to remove trailing spaces and punctuation.
    if ~isalnum(var_string{i}(end))
        var_string{i}(end) = [];
    end
%     assignin('caller', var_string{i}, data(:,j));
 end
%% Write the remainaing config information to the workspace

assignin('caller','Title', Title);
assignin('caller','Version', Version);
assignin('caller','Total_Channels', No_Ch);
assignin('caller','Analogue_Channels', Ana_Ch);
assignin('caller','Digital_Channels', Dig_Ch);
assignin('caller','Frequency', frequency);
assignin('caller','Sample_rate', samp_rate);
assignin('caller','Start_date', start_date);
assignin('caller','Start_time', start_time);
assignin('caller','End_date', end_date);
assignin('caller','End_time', end_time);
% assignin('caller','config', (cfg_string'));

%% Now let's post-process the data to produce the final waveforms
if Ana_Ch >= 1

%     dat = zeros(dat_len, Ana_Ch+2);
%     dat = zeros(size(data,1), Ana_Ch+2);
    
    % step through the data configuration
    for i = 1 : Ana_Ch

        j = i + 2;
        % Limit the range of the result
        min_level = sscanf(char(cfg_string{1,j}(9)),'%f');
        max_level = sscanf(char(cfg_string{1,j}(10)),'%f');
        
        % The value is scaled by the equation [aX + b]
        multiplier = sscanf(char(cfg_string{1,j}(6)),'%f'); % a
        offset = sscanf(char(cfg_string{1,j}(7)),'%f');     % b

%         % Lower limit check
%         data(find(data(:,j) < min_level),j) = NaN;
%         % Upper limit check
%         data(find(data(:,j) > max_level),j) = NaN;
        
%         dat(:,i) = data(:,j) * multiplier  + offset;
        dat = data(:,j) * multiplier  + offset;
        % If the Primary and Secondary scaling information is present,
        % apply that too
        if length(cfg_string{1,j}) > 10

            pri_scaling = sscanf(char(cfg_string{1,j}(11)),'%f');
            sec_scaling = sscanf(char(cfg_string{1,j}(12)),'%f');
            pri_sec = char(cfg_string{1,j}(13));

            if (strcmpi(pri_sec,'P'))
                
                %dat(:,i) = dat(:,i) * pri_scaling;

            else

%                 dat(:,i) = dat(:,i) * (pri_scaling/sec_scaling);
                dat = dat * (pri_scaling/sec_scaling);

            end
        end
%         assignin('caller', var_string{i}, dat(:,i));
        assignin('caller', var_string{i}, dat);

    end
end
if Dig_Ch >= 1
    % step through the data configuration
    for i = 1 : Dig_Ch
        if (strcmpi(data_type,'ASCII'))
            j = i + 2 + Ana_Ch;
            assignin('caller', var_string{i + Ana_Ch}, ...
            single(xor(data(:,j),str2num(cfg_string{1,j}{5}))));
        else
            j = 2 + Ana_Ch + ceil(i/16);
            jj = rem(i-1,16)+1;
            assignin('caller',var_string{i + Ana_Ch}, ...
            single(xor(bitget(data(:,j),jj),str2num(cfg_string{1,j}{5}))));
        end
    end
end

        % Limit the range of the result

%% And finally, plot the results. 
% Analogues in multiple subplots (V, I, Other) in first figure. 
% Digitals in 8 subplots per figure 

if No_Ch >= 1


    %    Initialise local variables 
    colour = 'null';
    colour_v = 'null';
    colour_i = 'null';
    colour_x = 'null';

    no_plots = 1;

    count = 9;
    sub_plot = 1;

    % Pops up a menu dialog, allowing the user to choose which plots to
    % display
    if nargin ~= 0
        x = 1;
    else
    x = menu('What do you want to plot?','Nothing','Analogue Channels','Digital Channels','All Channels');
    end
    switch (x)
        % Don't plot anything
        case 1
            start_count = 1;
            target_count = 1;
            % Analogue channels only
        case 2
            start_count = 1;
            target_count = Ana_Ch;
            % Digital channels only
        case 3
            start_count = Ana_Ch + 1;
            target_count = No_Ch;
            % Analogue & digital channesl
        case 4
            start_count = 1;
            target_count = No_Ch;
            % Default case - will never happen
        otherwise
            start_count = -1;
            target_count = -1;
        end

        if x > 1

            hold off;
            close all;
            % Only need to work out the number of plots if we're going to plot
            % the analogue channels
            if x == 2 || x == 4

                for i = 1 : Ana_Ch

                    j = i + 2;

                    % scan data types. This way we know how many graphs to plot in the analogues figure.
                    switch char(cfg_string{1,j}(5)) 

                        case {'V', 'kV', 'KV', 'MV', 'mV'}

                        case {'A', 'mA', 'kA', 'KA'}
                            if no_plots < 2
                                no_plots = 2;
                            end

                        otherwise
                            if no_plots < 3
                                no_plots = 3;
                            end
                        end
                    end

                    figure(1);hold on;

                end

                p = cell(No_Ch,1);

                % Scan through the data and plot.
                for i = start_count : target_count

                    j = i + 2;

                    if i <= Ana_Ch

                        % Plot the analogue channels
                        switch char(cfg_string{1,j}(5)) 

                            case {'V', 'kV', 'KV', 'MV', 'mV'}
                                colour_v = get_colour(colour_v);
                                colour = colour_v;
                                sub_plot = 1;

                            case {'A', 'mA', 'kA', 'KA'}
                                colour_i = get_colour(colour_i);
                                colour = colour_i;
                                sub_plot = 2;

                            otherwise
                                colour_x = get_colour(colour_x);
                                colour = colour_x;
                                sub_plot = 3;

                            end
                            hold on;

%                             subplot(no_plots, 1, sub_plot);
                            figure(sub_plot);
                            hold on;
                            p{i} = plot(t, evalin('caller', var_string{i}), 'color', colour);
%                             legend(p{i},var_string{i});
                            % Read the current legend
                            h = findobj (gcf, "tag", "legend");
                            set(h,'interpreter','none');
                            if isempty(h)
                                y = [];
                            else
                                y = get(h(1), 'string');
                            end
                            %             y = get(legend, 'userdata');

                            % Append the new item to the legend for this plot.
                            legend_string = char(cfg_string{1,j}(2));
                            %             legend_string = cfg_string{1,j}(2);
                            %             legend(p{i,1},[y, legend_string]);
                            if isempty(y)
                                legend(legend_string);
                                %             legend(legend_string);
                            else
                                legend(y{:}, legend_string);
                                %             legend([char(y.lstrings), legend_string]);
                                %             legend([y.lstrings, legend_string]);
                                %             legend([y.lstrings, legend_string]);
                            end 
                        else

                            % Plot the digital channels.
                            if count > 8
                                figure; hold on;
                                sub_plot = 1;
                                count = 1;
                                colour = 'null';
                            end

                            colour = get_colour(colour);

                            subplot(8, 1, sub_plot), p{i} = area(t, evalin('caller', var_string{i}), ...
                                'facecolor',colour);
                            y = legend(p{i},var_string{i});
                            set(y,'interpreter','none');

                            sub_plot = sub_plot + 1;
                            count = count + 1;
                        end

                    end
                end
            end

%% Colour function
% Steps through the colour palette in a defined order. Traditionally power
% systems use Red Yellow Blue for the 3 phase representation of waveforms.

function new_colour = get_colour(colour)

switch colour
    case 'null'
        new_colour = 'red';
    case 'red'
        new_colour = 'yellow';
    case 'yellow'
        new_colour = 'blue';
    case 'blue'
        new_colour = 'green';
    case 'green'
        new_colour = 'cyan';
    case 'cyan'
        new_colour = 'magenta';
    case 'magenta'
        new_colour = 'black';
    case 'black'
        new_colour = 'red';
    otherwise
        new_colour = 'red';
end

function out = flinescan(rem,dlm)
%
% Written by Gopal on 30th Dec 2010
% as a subfunction to scan an line and dividing it into separate cells as per dlimiters
%
k = 1;
while ~isempty(rem)
[out{k},rem] = strtok_singleDlm(rem,dlm);
k=k+1;
end

%%%% Subfunction strtok_singleDlm
%%%% A specelization of the default strtok
function [token, remainder] = strtok_singleDlm(string,delimiters);
len = length(string);
i = 1;
if(string(i) == delimiters)
    i = i+1;
end
start = i;
while (~any(string(i) == delimiters))
    i = i + 1;
    if (i > len), break, end
end
finish = i - 1;
token = string(start:finish);
remainder = string(finish +1:len);
